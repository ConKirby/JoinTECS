---
export interface Props {
  variant?: 'stripe' | 'ul' | 'dogpatch' | 'default';
  gap?: number;
  speed?: number;
  colors?: string;
  noFocus?: boolean;
  className?: string;
  href?: string;
  alt?: string;
  logoSrc?: string;
}

const {
  variant = 'default',
  gap,
  speed,
  colors,
  noFocus,
  className = '',
  href,
  alt = '',
  logoSrc
} = Astro.props;

const VARIANTS = {
  default: {
    activeColor: null,
    gap: 5,
    speed: 35,
    colors: '#f8fafc,#f1f5f9,#cbd5e1',
    noFocus: false
  },
  stripe: {
    activeColor: '#e0f2fe',
    gap: 8,
    speed: 30,
    colors: '#635bff,#7c3aed,#8b5cf6',
    noFocus: false
  },
  ul: {
    activeColor: '#fef08a',
    gap: 6,
    speed: 25,
    colors: '#3ea86f,#4fb87a,#5fc885',
    noFocus: false
  },
  dogpatch: {
    activeColor: '#fecdd3',
    gap: 7,
    speed: 40,
    colors: '#000000,#1a1a1a,#333333',
    noFocus: false
  }
};

const variantCfg = VARIANTS[variant] || VARIANTS.default;
const finalGap = gap ?? variantCfg.gap;
const finalSpeed = speed ?? variantCfg.speed;
const finalColors = colors ?? variantCfg.colors;
const finalNoFocus = noFocus ?? variantCfg.noFocus;
---

<div 
  class={`pixel-card ${className}`} 
  data-gap={finalGap}
  data-speed={finalSpeed}
  data-colors={finalColors}
  data-no-focus={finalNoFocus}
  tabindex={finalNoFocus ? -1 : 0}
>
  <canvas class="pixel-canvas"></canvas>
  {href && logoSrc && (
    <a href={href} target="_blank" rel="noopener noreferrer">
      <img class="supporter-logo" src={logoSrc} alt={alt}/>
    </a>
  )}
  <slot />
</div>

<script>
  class Pixel {
    constructor(canvas, context, x, y, color, speed, delay) {
      this.width = canvas.width;
      this.height = canvas.height;
      this.ctx = context;
      this.x = x;
      this.y = y;
      this.color = color;
      this.speed = this.getRandomValue(0.1, 0.9) * speed;
      this.size = 0;
      this.sizeStep = Math.random() * 0.4;
      this.minSize = 0.5;
      this.maxSizeInteger = 2;
      this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);
      this.delay = delay;
      this.counter = 0;
      this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;
      this.isIdle = false;
      this.isReverse = false;
      this.isShimmer = false;
    }

    getRandomValue(min, max) {
      return Math.random() * (max - min) + min;
    }

    draw() {
      const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;
      this.ctx.fillStyle = this.color;
      this.ctx.fillRect(this.x + centerOffset, this.y + centerOffset, this.size, this.size);
    }

    appear() {
      this.isIdle = false;
      if (this.counter <= this.delay) {
        this.counter += this.counterStep;
        return;
      }
      if (this.size >= this.maxSize) {
        this.isShimmer = true;
      }
      if (this.isShimmer) {
        this.shimmer();
      } else {
        this.size += this.sizeStep;
      }
      this.draw();
    }

    disappear() {
      this.isShimmer = false;
      this.counter = 0;
      if (this.size <= 0) {
        this.isIdle = true;
        return;
      } else {
        this.size -= 0.1;
      }
      this.draw();
    }

    shimmer() {
      if (this.size >= this.maxSize) {
        this.isReverse = true;
      } else if (this.size <= this.minSize) {
        this.isReverse = false;
      }
      if (this.isReverse) {
        this.size -= this.speed;
      } else {
        this.size += this.speed;
      }
    }
  }

  function getEffectiveSpeed(value, reducedMotion) {
    const min = 0;
    const max = 100;
    const throttle = 0.001;
    const parsed = parseInt(value, 10);

    if (parsed <= min || reducedMotion) {
      return min;
    } else if (parsed >= max) {
      return max * throttle;
    } else {
      return parsed * throttle;
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const cards = document.querySelectorAll('.pixel-card');
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    cards.forEach(card => {
      const canvas = card.querySelector('.pixel-canvas');
      if (!canvas) return;

      let pixels = [];
      let animationId = null;
      let timePrevious = performance.now();

      const initPixels = () => {
        const rect = card.getBoundingClientRect();
        const width = Math.floor(rect.width);
        const height = Math.floor(rect.height);
        const ctx = canvas.getContext('2d');

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        const gap = parseInt(card.dataset.gap) || 5;
        const speed = parseInt(card.dataset.speed) || 35;
        const colors = card.dataset.colors || '#f8fafc,#f1f5f9,#cbd5e1';
        const colorsArray = colors.split(',');

        pixels = [];
        for (let x = 0; x < width; x += gap) {
          for (let y = 0; y < height; y += gap) {
            const color = colorsArray[Math.floor(Math.random() * colorsArray.length)];

            const dx = x - width / 2;
            const dy = y - height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const delay = reducedMotion ? 0 : distance;

            pixels.push(new Pixel(canvas, ctx, x, y, color, getEffectiveSpeed(speed, reducedMotion), delay));
          }
        }
      };

      const doAnimate = (fnName) => {
        animationId = requestAnimationFrame(() => doAnimate(fnName));
        const timeNow = performance.now();
        const timePassed = timeNow - timePrevious;
        const timeInterval = 1000 / 60;

        if (timePassed < timeInterval) return;
        timePrevious = timeNow - (timePassed % timeInterval);

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let allIdle = true;
        for (let i = 0; i < pixels.length; i++) {
          const pixel = pixels[i];
          pixel[fnName]();
          if (!pixel.isIdle) {
            allIdle = false;
          }
        }
        if (allIdle) {
          cancelAnimationFrame(animationId);
        }
      };

      const handleAnimation = (name) => {
        cancelAnimationFrame(animationId);
        animationId = requestAnimationFrame(() => doAnimate(name));
      };

      const onMouseEnter = () => handleAnimation('appear');
      const onMouseLeave = () => handleAnimation('disappear');
      const onFocus = (e) => {
        if (e.currentTarget.contains(e.relatedTarget)) return;
        handleAnimation('appear');
      };
      const onBlur = (e) => {
        if (e.currentTarget.contains(e.relatedTarget)) return;
        handleAnimation('disappear');
      };

      // Initialize
      initPixels();
      
      // Event listeners
      card.addEventListener('mouseenter', onMouseEnter);
      card.addEventListener('mouseleave', onMouseLeave);
      if (!card.dataset.noFocus || card.dataset.noFocus === 'false') {
        card.addEventListener('focus', onFocus);
        card.addEventListener('blur', onBlur);
      }

      // Resize observer
      const observer = new ResizeObserver(() => {
        initPixels();
      });
      observer.observe(card);

      // Cleanup
      return () => {
        observer.disconnect();
        cancelAnimationFrame(animationId);
        card.removeEventListener('mouseenter', onMouseEnter);
        card.removeEventListener('mouseleave', onMouseLeave);
        card.removeEventListener('focus', onFocus);
        card.removeEventListener('blur', onBlur);
      };
    });
  });
</script>

<style>
  .pixel-canvas {
    width: 100%;
    height: 100%;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .pixel-card {
    height: 200px;
    width: 100%;
    position: relative;
    overflow: hidden;
    display: grid;
    place-items: center;
    aspect-ratio: 4 / 3;
    border: 1px solid var(--border);
    border-radius: 12px;
    isolation: isolate;
    transition: border-color 200ms cubic-bezier(0.5, 1, 0.89, 1);
    user-select: none;
    background: var(--bg);
  }

  .pixel-card::before {
    content: '';
    position: absolute;
    inset: 0;
    margin: auto;
    aspect-ratio: 1;
    background: radial-gradient(circle, rgba(0,0,0,0.1), transparent 85%);
    opacity: 0;
    transition: opacity 800ms cubic-bezier(0.5, 1, 0.89, 1);
    z-index: 2;
  }

  .pixel-card:hover::before,
  .pixel-card:focus-within::before {
    opacity: 1;
  }

  .pixel-card a {
    position: relative;
    z-index: 3;
    display: block;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .supporter-logo {
    max-width: 80%;
    max-height: 60%;
    object-fit: contain;
    filter: brightness(0.9);
    transition: filter 200ms ease;
  }

  .pixel-card:hover .supporter-logo,
  .pixel-card:focus-within .supporter-logo {
    filter: brightness(1);
  }

  /* Mobile adjustments */
  @media (max-width: 768px) {
    .pixel-card {
      height: 150px;
    }
  }
</style>
